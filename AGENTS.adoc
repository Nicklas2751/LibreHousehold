= AGENTS - LibreHousehold Context for AI Assistants

This document serves as context and quick reference for AI assistants helping with LibreHousehold development. It summarizes the most important architectural decisions and concepts.

== Project Overview

LibreHousehold is a free and open-source software for managing household expenses and tasks. The project is currently in active development (WIP).

=== Main Goals
- Completely free
- No ads
- Modern user interface
- Easy to use
- Easy to self-host
- Easy to contribute

=== Main Features
- Create households and invite other house-/flatmates
- Track and share expenses with your mates
- Create and manage tasks
- Work offline and sync later
- Responsive design for mobile and desktop

== Architecture Decisions (ADRs)

=== Frontend & Backend Separation (ADR-001)
- **Decision**: Split Frontend/Backend with API communication
- **Reason**: Simplicity, understandability, maintainability (QG4)
- **Technologies**: Separate applications with best-fitting technologies each

=== Backend Technology (ADR-002)
- **Language**: Kotlin
- **Reason**: Modern, Java-interoperable, good coroutine support, better performance than Python/Node.js
- **Container**: Docker support for easy hosting (QG3)

=== Architecture Style (ADR-004)
- **Style**: Modular Monolith (Modulith)
- **Reason**: Combination of monolith simplicity and microservice modularity
- **Advantage**: Modules can be extracted to microservices later

=== Frontend Technology (ADR-006)
- **Technology**: Progressive Web App (PWA)
- **Reason**: Cross-platform, no app store costs, easy to host
- **Language**: TypeScript (ADR-008) for type safety and maintainability

== Quality Goals

[cols="1,4,8"]
|===
|ID |Quality Goal |Motivation

|QG1 |Easy to learn (Learnability) |Users should be able to use the app without reading a manual or getting training
|QG2 |Secure (Security) |Expenses are sensitive data - integrity and confidentiality are important
|QG3 |Easy to host (Flexibility) |Technical users should be able to host the app themselves without much effort
|QG4 |Maintainable (Maintainability) |Code should be understandable and modifiable for open-source contributions
|===

== System Architecture

=== High-Level Structure
- **Frontend**: Progressive Web App (PWA) with TypeScript
- **Backend**: Kotlin-based Modular Monolith
- **External Systems**: E-Mail Server for notifications

=== Modules (Frontend & Backend)

[cols="2,5"]
|===
|Module |Responsibility

|**Expenses** |Managing expenses (CRUD operations)
|**Tasks** |Managing tasks (CRUD operations)
|**User Settings** |User-specific settings, changing login data
|**App Settings** |Frontend-specific settings (frontend only)
|**Household** |Creating/managing households, inviting/removing users
|**Setup** |Initial application setup for administrators
|**Administration** |Application management, user management, system settings
|**Notifications** |Sending/displaying notifications, configuration
|===

=== Actors
- **User**: Normal users of the app for household/expense management
- **Administrator**: Hosts and manages an app instance
- **E-Mail Server**: External system for email delivery

== Development Context

=== Project Structure
```
LibreHousehold/
├── backend/           # Kotlin Backend (Modular Monolith)
├── frontend/          # TypeScript PWA
├── docs/
│   └── architecture/  # Arc42 Architecture Documentation
│       ├── adrs/      # Architecture Decision Records
│       └── chapters/  # Arc42 Chapters
├── build/             # Build Artifacts
└── README.adoc        # Project README
```

=== Important Design Principles
1. **Modularity**: Clear module boundaries with defined interfaces
2. **Offline-First**: App should work without internet connection
3. **Responsive Design**: Mobile-first approach
4. **Self-hostable**: Docker containers for easy deployment
5. **Open Source**: Community-friendly and contribution-encouraging

== Technology Stack

=== Backend
- **Language**: Kotlin
- **Architecture**: Modular Monolith (Modulith)
- **Deployment**: Docker Container
- **Security**: Argon2id for password hashing (ADR-009)

=== Frontend
- **Type**: Progressive Web App (PWA)
- **Language**: TypeScript
- **Framework**: [To be determined - probably Svelte based on ADR-008 context]

=== External Integrations
- E-Mail Server for notifications and invitations

== Status & Development State

The project is in **active development** (Work in Progress). The architecture is defined, but implementation is ongoing.

== Important Notes for AI Assistants

1. **Maintainability is Priority**: Code should be understandable for open-source contributions
2. **Respect Module Boundaries**: Modules communicate only through defined interfaces
3. **Mobile-First**: UI/UX decisions should consider mobile devices
4. **Security**: Handle sensitive data (expenses) securely
5. **Deployment**: Changes should consider Docker containerization

== Guardrails for AI Agents

=== Workflow Rules

1. **ALWAYS create a plan first** in AsciiDoc under `.agent-plans/` before implementing anything
2. **Plan must be explicitly confirmed by the user** before starting implementation
3. This file (AGENTS.adoc) is the central reference for all important information

=== Svelte MCP Tools

* Call `list-sections` first to discover all available documentation sections
* Use `get-documentation` to fetch all relevant sections at once
* `svelte-autofixer` **MUST** be used before sending Svelte code to the user
* Only use `playground-link` after user confirmation

=== Context7

* Use Context7 for code generation, setup, and API documentation

=== OpenAPI Development

* **ALWAYS** validate OpenAPI changes with Spectral MCP before committing
* Ensure all new schemas and properties have `example` values
* Use PATCH for partial resource updates, with the request body containing the fields to update
* Follow REST best practices: path identifies the resource, body contains the changes
* After OpenAPI changes, regenerate the TypeScript client with `npm run openapi`

=== Test-Driven Development (TDD)

* **Follow TDD** for all business logic: Write tests FIRST (RED), then implement (GREEN), then refactor
* **Unit tests required** for all pure functions and business logic
* **UI-only changes** (visual, styling) do not require tests
* Test files: `*.spec.ts` next to the source file
* Run tests with: `npm run test`

=== Error Handling

* Show toast notifications on errors (using the toast store)
* Use optimistic updates for UI responsiveness
* Background saves should not block user interaction

== Frontend-specific Details

=== Technology Stack (Details)

* **Framework**: SvelteKit 5 with TypeScript
* **State Management**: Svelte Stores with `writable` and Svelte 5 Runes
* **i18n**: Paraglide (`$lib/paraglide/messages.js`)
* **Styling**: DaisyUI + Tailwind CSS
* **OpenAPI Client**: Generated TypeScript client under `src/generated-sources/openapi`

=== Important Frontend Files

[cols="1,2"]
|===
|File |Description

|`frontend/src/lib/stores/taskStore.ts`
|Store for tasks with API functions

|`frontend/src/lib/stores/memberStore.ts`
|Store for household members

|`frontend/src/lib/stores/householdState.svelte.ts`
|Svelte 5 Rune-based state for the household

|`frontend/src/lib/taskDueCalculator.ts`
|Logic for due dates and recurrence

|`frontend/src/routes/app/tasks/[[new]]/+page.svelte`
|Task overview and creation page

|===

=== Store Pattern

Stores use the pattern with `Configuration` and an `Api` class:

[source,typescript]
----
const apiConfig = new Configuration({basePath: '/api'});
const api = new TasksApi(apiConfig);

export const functionName = async (householdId: string, ...): Promise<ReturnType> => {
    // API call
    // Store update
};
----

== Findings & Notes

=== Task Schema

The `Task` schema has a `done` field (date format) that either contains a date or is null.

=== Recurring Tasks

* `recurring: boolean`
* `recurrenceUnit`: days, weeks, months, years
* `recurrenceInterval`: count (min 1)
* For recurring tasks, the task is "done" if the done date is after the last due date

== Current Task: Migration zu Svelte 5 State API ($app/state)

=== Summary

Migrate from deprecated `page` from `$app/stores` to the new Svelte 5 API `page` from `$app/state`.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Change import from '$app/stores' to '$app/state' |✅ Done
|2 |Remove $ prefix: `$page` → `page` (10 occurrences) |✅ Done
|3 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **Svelte 5 State API**: `import {page} from '$app/state'` (no $ prefix in usage)
* **Key Difference**:
  - Old (deprecated): `$page.url.pathname` (with $)
  - New (Svelte 5): `page.url.pathname` (without $)
* **Rune-based**: State is automatically reactive through Svelte 5 Runes
* **Bundle Size**: Smaller bundle (app/_layout: 11.94 KB → 10.89 KB)
* **Changes**: 1 import + 10 replacements (5 mobile buttons + 5 desktop links)

=== Migration Pattern

**Before**:
```svelte
import {page} from '$app/stores';
class:dock-active={$page.url.pathname === '/app/dashboard'}
```

**After**:
```svelte
import {page} from '$app/state';
class:dock-active={page.url.pathname === '/app/dashboard'}
```

== Previous Task: Dynamische Active-State für Menü

=== Summary

Make the menu (both mobile and desktop) show the currently displayed page as active, instead of always showing only the dashboard as active.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Import $page store from '$app/stores' |✅ Done (migrated to $app/state)
|2 |Mobile: Dynamic `class:dock-active` for all 5 buttons |✅ Done
|3 |Desktop: Dynamic `class:menu-active` for all 5 links |✅ Done
|4 |Use `startsWith` for Tasks (includes /app/tasks/new) |✅ Done
|5 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **SvelteKit page State**: `page.url.pathname` to get current route (Svelte 5 State API)
* **class: Directive**: `class:class-name={boolean}` dynamically adds CSS classes
* **Tasks Special Case**: Uses `startsWith('/app/tasks')` because of subpage `/app/tasks/new`
* **Other Pages**: Use `=== '/app/...'` for exact match (no subpages yet)
* **Mobile**: `dock-active` class on buttons
* **Desktop**: `menu-active` class on links
* **Badge preserved**: Task counter badge (99+) remains on desktop menu

=== Routes & Active States

[cols="2,2"]
|===
|Route |Active Menu Item

|`/app/dashboard` |Dashboard
|`/app/tasks` |Tasks
|`/app/tasks/new` |Tasks (due to startsWith)
|`/app/expenses` |Expenses
|`/app/statistics` |Statistics
|`/app/settings` |Settings
|===

== Previous Task: Mobile View für Tasks-Seite

=== Summary

Add a mobile view for the tasks page with a scrollable full-screen list between the header (title, create button, filters) and the bottom navigation.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Add mobile task list after filter buttons |✅ Done
|2 |Card-style layout with touch-friendly spacing |✅ Done
|3 |Same features as desktop (checkbox, overdue detection, member display) |✅ Done
|4 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **Mobile-only**: `md:hidden` class ensures list only shows on mobile (< 768px)
* **Card-style items**: `bg-base-200 rounded-lg p-3` for better touch interaction
* **Bottom padding**: `pb-20` (80px) prevents bottom navigation from covering tasks
* **Natural scrolling**: No fixed container, uses page scrolling (better for touch devices)
* **Consistent layout**: Same title-left/date-right layout as desktop
* **Shared logic**: Uses same `filteredTasks` $derived store as desktop
* **Responsive**: Desktop list unchanged, mobile list appears below filters

=== Layout Structure

```
Mobile (< 768px):
┌─────────────────────────┐
│ Titel + Create Button   │ ← PageTitleActionBar
│ Filter Buttons          │ ← Already existed
├─────────────────────────┤
│ Scrollable Task List    │ ← NEW!
│ (Card-style items)      │
├─────────────────────────┤
│ Bottom Navigation       │
└─────────────────────────┘
```

== Previous Task: Fix Overdue Detection - Exclude Completed Tasks

=== Summary

Bug fix: Completed tasks should NOT be marked as overdue, even if they were completed after the due date. Uses `checkIsDone()` from `taskDueCalculator` which handles both regular and recurring tasks correctly.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Tasks Page: Add `checkIsDone(task)` check to `isTaskOverdue` |✅ Done
|2 |Dashboard: Add `checkIsDone(task)` check to `mapTaskToDisplayItem` |✅ Done
|3 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **Uses `checkIsDone()` instead of simple `task.done` check**: Handles recurring tasks correctly
* **Recurring Tasks**: A task with `done` is only done for the LAST due date. If a new occurrence is due, it's overdue again
* **Non-recurring Tasks**: `checkIsDone` checks if `done > dueDate`
* **Logic**: Task is overdue if: has dueDate AND not done AND dueDate < today

=== Bug Description

**Before**: A task with `dueDate: 01.12.2024` and `done: 05.12.2024` was incorrectly marked as overdue (secondary color).

**After**: Completed tasks are never marked as overdue, regardless of when they were completed.

== Previous Task: Tasks Page - Overdue Detection & Inline Date

=== Summary

Add overdue detection and inline date display to the tasks page, matching the dashboard layout.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Add `isTaskOverdue` function |✅ Done
|2 |Change layout: Flexbox for inline date (title left, date right) |✅ Done
|3 |Add `text-secondary` class for overdue tasks |✅ Done
|4 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **Consistent with Dashboard**: Same overdue logic and layout pattern
* **Overdue Detection**: Tasks with `dueDate < today` marked with `text-secondary`
* **Inline Layout**: Title left-aligned, date right-aligned in one line using Flexbox
* **Member Display**: Still shown below title (vertically stacked)
* Date format: `toLocaleDateString('de-DE')` for German formatting

== Previous Task: Dashboard Upcoming Tasks

=== Summary

Display the next 10 pending tasks on the dashboard with a generic ListCard component that can also be used for expenses later.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Create generic ListCard with DisplayItem interface and itemMapper prop |✅ Done
|2 |Add TaskStore integration to dashboard |✅ Done
|3 |Implement mapTaskToDisplayItem with overdue detection |✅ Done
|4 |Filter, sort, and limit tasks to 10 |✅ Done
|5 |Validation & Build |✅ Done
|===

=== Implementation Notes

* **Generic ListCard** with `DisplayItem` interface: `{id, title, subtitle, isHighlighted}`
* **Mapper function pattern**: `itemMapper?: (item: any) => DisplayItem` for flexibility
* **Layout**: Title left-aligned, subtitle right-aligned in one line using Flexbox
* **Overdue tasks** highlighted with DaisyUI `text-secondary` class
* **Reusable** for expenses: just provide different mapper function
* Tasks sorted by due date (ascending), limited to 10 items

== Previous Task: Task Filters

=== Summary

Implement task filtering functionality (All, Assigned to Me, Pending, Completed).

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |Write unit tests for `filterTasks` function (TDD RED phase) |✅ Done
|2 |Implement `taskFilter.ts` with `filterTasks` function (TDD GREEN phase) |✅ Done
|3 |Integrate into UI with `$derived` and `bind:group` |✅ Done
|4 |All tests pass (124 tests), build successful |✅ Done
|===

=== Implementation Notes

* `TaskFilterType` const exported from `taskFilter.ts`
* `filterTasks(tasks, filterType, currentUserId)` - pure function for filtering
* Uses `checkIsDone()` from `taskDueCalculator.ts` for pending/completed logic
* Radio buttons use `bind:group` for Svelte 5 compatibility

== Previous Task: Save Task Done Date

=== Summary

Implement a feature to persist the "task done" date when a user marks a task as done or undone.

=== Implementation Status

[cols="1,2,1"]
|===
|Step |Description |Status

|1 |OpenAPI: PATCH endpoint `/household/{householdId}/tasks/{taskId}` with `TaskUpdate` schema |✅ Done
|2 |Generate TypeScript client (`npm run openapi`) |✅ Done
|3 |Task Store: `updateTaskDoneStatus` function with optimistic update and error handling |✅ Done
|4 |Task Page: Connect checkbox to new function |✅ Done
|5 |Build & Validation: svelte-check, autofixer, npm run build |✅ Done
|===

=== Implementation Notes

* The checkbox uses optimistic updates - UI updates immediately, API call happens in background
* On API error: rollback to previous state and show error toast
* The `TaskUpdate` schema is extensible for future partial updates (e.g., title, description)

=== Implementation Steps

1. **OpenAPI Specification** (`api/openapi.yml`)
   - Add `PATCH /household/{householdId}/tasks/{taskId}` endpoint
   - Resource ID (task id) in path, field values in request body (REST best practice)
   - Include example for the new endpoint
   - **Validate with Spectral** before proceeding

2. **TypeScript Client Regeneration**
   - Run `npm run openapi` after OpenAPI changes

3. **Task Store** (`frontend/src/lib/stores/taskStore.ts`)
   - Add `updateTask` function with optimistic update pattern
   - Update local store after successful API call

4. **i18n Messages** (`frontend/messages/de.json`, `en.json`)
   - Add `tasks.save_error` message for error toast

5. **UI Integration** (`frontend/src/routes/app/tasks/[[new]]/+page.svelte`)
   - Connect checkbox to new store function
   - Optimistic update: immediate local state change
   - Background save: no loading state, user can continue
   - Error handling: rollback and show toast on failure

=== Key Decisions

- **PATCH on resource path** (`/tasks/{taskId}`), not on field (`/tasks/{taskId}/done`)
- **Request body contains fields** to update (JSON Merge Patch pattern, RFC 7396)
- **Extensible design**: Same endpoint can later update other fields (title, assignedTo, etc.)

Last Updated: December 2025
